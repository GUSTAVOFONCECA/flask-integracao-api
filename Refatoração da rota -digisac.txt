from flask import Blueprint, request, jsonify
import json
import logging
from datetime import datetime

from app.utils.utils import respond_with_200_on_exception
from app.services.renewal_services import (
    get_pending,
    is_contact_processing as is_processing,
    add_pending_message,
    set_processing_status,
    get_next_pending_message,
    mark_message_as_processed,
)
from app.services.webhook_services import (
    _get_contact_number_by_id,
    interpret_certification_response,
    send_proposal_file,
    build_certification_message,
    update_crm_item,
    send_safe_processing_notification,
)
from app.services.conta_azul.conta_azul_services import handle_sale_creation_certif_digital

logger = logging.getLogger(__name__)
webhook_bp = Blueprint("digisac", __name__)


@webhook_bp.route("/digisac", methods=["POST"])
@respond_with_200_on_exception
def resposta_certificado_digisac():
    """Processa mensagens do Digisac em fila por empresa (spa_id)"""
    logger.info("/digisac: Webhook recebido")
    payload = request.get_json(silent=True)
    if not payload:
        logger.warning("/digisac: Payload JSON ausente.")
        return jsonify({"error": "Payload JSON ausente"}), 400

    data = payload.get("data", {})
    contact_id = data.get("contactId")
    msg = data.get("message", {})
    message_id = msg.get("id")
    user_message = msg.get("text", "")

    if not contact_id or not message_id:
        logger.warning("/digisac: Campos obrigatórios ausentes.")
        return jsonify({"error": "contactId e message.id são obrigatórios"}), 400

    contact_number = _get_contact_number_by_id(contact_id)
    if not contact_number:
        logger.error(f"Contato não encontrado: {contact_id}")
        return jsonify({"status": "ignored", "reason": "Contato desconhecido"}), 200

    # Localiza pendência ativa e extrai spa_id
    pending = get_pending(contact_number=contact_number, context_aware=True)
    if not pending:
        logger.info(f"Nenhuma pendência ativa para: {contact_number}")
        return jsonify({"status": "ignored", "reason": "Sem pendência ativa"}), 200

    spa_id = pending.get('spa_id')

    # Se já estiver processando, enfileira
    if is_processing(spa_id):
        logger.info(f"SPA {spa_id} em processamento. Enfileirando mensagem {message_id}.")
        queue_id = add_pending_message(spa_id, payload)
        send_safe_processing_notification(spa_id)
        return jsonify({"status": "queued", "queue_id": queue_id}), 200

    # Caso contrário, processa imediatamente
    try:
        set_processing_status(spa_id, True)
        _process_digisac_message(spa_id, message_id, user_message, payload)
    except Exception as e:
        logger.exception(f"Erro no processamento de SPA {spa_id}: {e}")
        return jsonify({"error": str(e)}), 500
    finally:
        set_processing_status(spa_id, False)
        _process_pending_messages(spa_id)

    return jsonify({"status": "processed"}), 200


def _process_digisac_message(spa_id: int, message_id: str, user_message: str, payload: dict):
    """Lógica de interpretação e ação para cada mensagem do usuário"""
    logger.info(f"Processando SPA {spa_id}, mensagem {message_id}")

    # Evita duplicação
    if mark_message_as_processed(spa_id, message_id, "check", payload) is False:
        logger.info(f"Mensagem duplicada ignorada: {message_id} para SPA {spa_id}")
        return

    # Interpreta intenção do cliente
    action = interpret_certification_response(user_message)
    pending = get_pending(spa_id=spa_id)
    status = pending.get('status')

    # Executa ação com base na intenção
    if action == 'renew' and status in ['pending', 'info_sent']:
        logger.info(f"[{spa_id}] Renew flow iniciado")
        send_proposal_file(pending['contact_number'], pending['company_name'], spa_id)
        result = handle_sale_creation_certif_digital(pending['contact_number'], pending['deal_type'])
        sale_id = result.get('sale', {}).get('id')
        # Atualiza CRM e pendência
        update_crm_item(137, spa_id, {'stageId': 'DT137_36:UC_90X241'})
        # registra nova fase
        from app.services.renewal_services import update_pending
        update_pending(spa_id=spa_id, status='sale_created', sale_id=sale_id, last_interaction=datetime.now())

    elif action == 'info' and status == 'pending':
        logger.info(f"[{spa_id}] Info flow")
        build_certification_message(pending['contact_number'], pending['contact_name'], pending['company_name'], 0)
        from app.services.renewal_services import update_pending
        update_pending(spa_id=spa_id, status='info_sent', last_interaction=datetime.now())

    elif action == 'refuse' and status != 'customer_retention':
        logger.info(f"[{spa_id}] Refuse flow")
        update_crm_item(137, spa_id, {'stageId': 'DT137_36:UC_AY5334'})
        from app.services.renewal_services import update_pending
        update_pending(spa_id=spa_id, status='customer_retention', last_interaction=datetime.now())

    else:
        logger.info(f"[{spa_id}] Ação desconhecida ou não aplicável: {action}")


def _process_pending_messages(spa_id: int):
    """Processa a fila de mensagens pendentes para um spa_id em ordem FIFO"""
    logger.info(f"Processando fila de SPA {spa_id}")
    while True:
        msg = get_next_pending_message(spa_id)
        if not msg:
            break
        msg_id = msg['id']
        payload = json.loads(msg['payload'])
        data = payload.get('data', {})
        message = data.get('message', {})
        try:
            set_processing_status(spa_id, True)
            _process_digisac_message(spa_id, message.get('id'), message.get('text', ''), payload)
            mark_message_as_processed(msg_id)
        except Exception as e:
            logger.exception(f"Erro ao processar pendente {msg_id} para SPA {spa_id}: {e}")
        finally:
            set_processing_status(spa_id, False)
